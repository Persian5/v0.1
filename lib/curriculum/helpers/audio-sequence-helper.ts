import { AudioSequenceStep, LexemeRef } from "../../types";
import { GrammarService } from "../../services/grammar-service";

/**
 * Internal helper function to generate audio-sequence steps
 * 
 * PHASE 4.2: Now supports LexemeRef[] (base vocab or grammar forms)
 * 
 * Audio-sequence steps play a sequence of Persian words and ask the user
 * to select the English meanings in the correct order.
 * 
 * Word banks are auto-generated by WordBankService using semantic distractor strategy.
 * 
 * IMPORTANT: Stores raw LexemeRef[] to avoid circular dependencies during curriculum initialization.
 * Resolution happens at runtime in the UI component.
 * 
 * @param sequence - Array of lexeme references in the order they should be played
 * @param expectedTranslation - English translation of the sequence (e.g., "Hello how are you")
 * @param points - Points for the audio-sequence exercise (default: 3)
 * @param autoPlay - Whether to auto-play audio sequence on load (default: undefined, component decides)
 * @param targetWordCount - Number of English words expected (overrides semantic unit calculation)
 * @param maxWordBankSize - Maximum number of options in word bank (default: 12)
 * @returns AudioSequenceStep with raw LexemeRef[] for runtime resolution
 * 
 * Examples:
 *   audioSequenceHelper(["salam", "chetori"], "Hello, how are you?")
 *   audioSequenceHelper([{ kind: "suffix", baseId: "khoob", suffixId: "am" }, "merci"], "I'm good, thank you")
 */
export function audioSequenceHelper(
  sequence: LexemeRef[],
  expectedTranslation: string,
  points: number = 3,
  autoPlay?: boolean,
  targetWordCount?: number,
  maxWordBankSize?: number
): AudioSequenceStep {
  // Store raw LexemeRef[] - resolution happens at runtime
  // For backward compat, also store string IDs where possible
  const legacySequence = sequence.map(ref => {
    if (typeof ref === 'string') {
      return ref;
    }
    // For grammar refs, use surface ID pattern (will be resolved at runtime)
    return `${ref.baseId}_${ref.suffixId}`;
  });
  
  return {
    type: "audio-sequence",
    points,
    data: {
      sequence: legacySequence,         // Backward compat
      lexemeSequence: sequence,         // NEW: Raw LexemeRef[] for runtime resolution
      expectedTranslation,
      ...(autoPlay !== undefined && { autoPlay }),
      ...(targetWordCount !== undefined && { targetWordCount }),
      ...(maxWordBankSize !== undefined && { maxWordBankSize })
    }
  };
}
